// -*- coding: utf-8; mode: groovy -*-

buildscript {
	repositories {
		mavenCentral()
		jcenter()
		maven { url "http://repo.spring.io/plugins-release" }
	}
	dependencies {
		classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2"
		classpath "com.diffplug.gradle.spotless:spotless:1.3.3"
		classpath "de.thetaphi:forbiddenapis:2.2"
		classpath "de.aaschmid:gradle-cpd-plugin:1.0"
	}
}

plugins {
	id "com.github.hierynomus.license" version "0.12.1"
}

ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name

defaultTasks "clean", "build"


allprojects {
	repositories {
		mavenCentral()
		jcenter()
	}
	group = "jp.xet.${githubProjectName}"
	version = currentVersion
}
description "Support library for Spring framework, AWS Java SDK and the others."

subprojects {
	apply plugin: "java"
	apply plugin: "maven"
	
	sourceCompatibility = 1.8
	targetCompatibility = 1.8
	
	// ======== code quality ========
	apply plugin: "checkstyle"
	apply plugin: "findbugs"
	apply plugin: "pmd"
	apply plugin: "cpd"
	apply plugin: "jacoco"
	apply plugin: "de.thetaphi.forbiddenapis"
	apply plugin: "com.diffplug.gradle.spotless"
	
	// compiler
	compileJava {
		options.compilerArgs << "-Xlint"
	}
	
	// jacoco
	jacocoTestReport {
		reports {
			xml.enabled false
			csv.enabled false
		}
	}
	
	// checkstyle
	checkstyle {
		toolVersion = "7.1.2"
		configFile = rootProject.file('config/checkstyle/checkstyle.xml')
	}
	checkstyleTest {
		configFile = rootProject.file("config/checkstyle/checkstyle-test.xml")
	}
	
	// workaround: see https://issues.gradle.org/browse/GRADLE-2888
	task verifyNoCheckstyleWarningsInMain {
		group = "verification"
		description = "Fail if checkstyleMain result contains warnings"
		doLast {
			File warningsFile = file('build/reports/checkstyle/main.xml')
			if (warningsFile.exists() && warningsFile.text.contains("<error ")) {
				throw new GradleException("There were checkstyle warnings! For more info check $warningsFile")
			}
		}
	}
	checkstyleMain.finalizedBy verifyNoCheckstyleWarningsInMain
	task verifyNoCheckstyleWarningsInTest {
		group = "verification"
		description = "Fail if checkstyleTest result contains warnings"
		doLast {
			File warningsFile = file('build/reports/checkstyle/test.xml')
			if (warningsFile.exists() && warningsFile.text.contains("<error ")) {
				throw new GradleException("There were checkstyle warnings! For more info check $warningsFile")
			}
		}
	}
	checkstyleTest.finalizedBy verifyNoCheckstyleWarningsInTest
	
	// findbugs
	findbugs {
		effort = "max"
		includeFilter = file("../config/findbugs/includeFilter.xml")
		excludeFilter = file("../config/findbugs/excludeFilter.xml")
	}
	tasks.withType(FindBugs) {
		reports {
			xml.enabled = false
			html.enabled = true
		}
	}
	
	// pmd
	pmd {
		consoleOutput = true
	}
	pmdMain {
		ruleSetFiles = files("../config/pmd/pmd-settings.xml")
		ruleSets = []  // To apply only the custom rules
	}
	pmdTest {
		ruleSetFiles = files("../config/pmd/pmd-settings-test.xml")
		ruleSets = []  // To apply only the custom rules
	}
	cpdCheck {
		reports {
			text.enabled = true
			xml.enabled = false
		}
		source = sourceSets.main.allJava // only main source
		ignoreFailures = true
	}
	
	// forbiddenapis
	forbiddenApisMain {
		bundledSignatures += [
			'jdk-system-out',
			'jdk-unsafe-' + project.sourceCompatibility,
			'jdk-internal-' + project.sourceCompatibility
		]
		signaturesFiles = fileTree(dir: "../config/forbiddenapis", include: "*.txt")
		ignoreFailures = false
	}
	forbiddenApisTest {
		bundledSignatures += [
			'jdk-system-out',
			'jdk-internal-' + project.sourceCompatibility
		]
		ignoreFailures = false
	}
	
	// spotless
	spotless {
		java {
			licenseHeaderFile '../config/spotless/spotless.license.java'
			importOrderFile   '../config/spotless/spotless.importorder'
			eclipseFormatFile '../config/spotless/spotless.eclipseformat.xml'
			
			// Eclipse formatter screws up long literals with underscores inside of annotations (see issue #14)
			//    @Max(value = 9_999_999 L) // what Eclipse does
			//    @Max(value = 9_999_999L)  // what I wish Eclipse did
			custom 'Long literal fix', { it.replaceAll('([0-9_]+) [Ll]', '$1L') }
			
			// Eclipse formatter puts excess whitespace after lambda blocks
			//    funcThatTakesLambdas(x -> {} , y -> {} )	// what Eclipse does
			//    funcThatTakesLambdas(x -> {}, y -> {})	// what I wish Eclipse did
			custom 'Lambda fix', { it.replace('} )', '})').replace('} ,', '},') }
			
			indentWithTabs()
			endWithNewline()
			
			customReplaceRegex 'Add space before comment asterisk', '^(\\t*)\\*', '$1 *'
	//		customReplaceRegex 'Remove indent before line comment', '^\\t*//', '//'
		}
		
		// this will create two tasks: spotlessMiscCheck and spotlessMiscApply
		format 'misc', {
			// target determines which files this format will apply to
			// - if you pass a string or a list of strings, they will be treated
			//	   as 'include' parameters to a fileTree in the root directory
			// - if you pass a FileCollection, it will pass through untouched
			//	   e.g. project.files('build.gradle', 'settings.gradle')
			// - if you pass anything else, it will be sent to project.files(yourArg)
			target '**/*.gradle', '**/*.md', '**/.gitignore'
			
			// spotless has built-in rules for the most basic formatting tasks
			indentWithTabs() // or spaces. Takes an integer argument if you don't like 4
			endWithNewline()
		}
	}
	

	// ======== create source and javadoc bundles ========
	task sourcesJar(type: Jar, dependsOn: classes) {
		classifier = "sources"
		from sourceSets.main.allSource
	}

	task javadocJar(type: Jar, dependsOn: javadoc) {
		classifier = "javadoc"
		from javadoc.destinationDir
	}

	javadoc {
		failOnError = false
	}

	artifacts {
		archives sourcesJar
		archives javadocJar
	}

	configurations {
		deployerJars
	}

	repositories {
		mavenCentral()
		maven { url "http://maven.xet.jp/release" } // for baseunits
	}
	
	dependencies {
		compile "org.projectlombok:lombok:1.16.2"
		compile "org.slf4j:slf4j-api:$slf4jVersion"
		testCompile "org.slf4j:jul-to-slf4j:$slf4jVersion"
		testCompile "ch.qos.logback:logback-classic:$logbackVersion"
		testCompile "junit:junit:$junitVersion"
		testCompile "org.hamcrest:hamcrest-library:$hamcrestVersion"
		testCompile "org.mockito:mockito-core:$mockitoCoreVersion"
	}
	
	
	// ======== License =======
	apply plugin: "license"
	license {
		ext.year = Calendar.getInstance().get(Calendar.YEAR)
		header rootProject.file("copyright/HEADER")
		strictCheck true
		mapping {
			java = "SLASHSTAR_STYLE"
		}
		exclude "**/*.json"
	}
	
	
	// ======== Publishing =======
	apply plugin: 'maven-publish'
	publishing {
		publications {
			mavenJava(MavenPublication) {
				from components.java
				artifact sourcesJar {
					classifier "sources"
				}
				artifact javadocJar {
					classifier "javadoc"
				}
				pom.withXml {
					asNode().children().last() + {
						resolveStrategy = Closure.DELEGATE_FIRST
						name project.name
						description project.description
						inceptionYear "2015"
						licenses {
							license {
								name "The Apache Software License, Version 2.0"
								url "http://www.apache.org/license/LICENSE-2.0.txt"
								distribution "repo"
							}
						}
						developers {
							developer {
								id "dai0304"
								name "MIYAMOTO Daisuke"
								email "dai.0304@gmail.com"
							}
						}
					}
				}
			}
		}
	}
	
	if (project.hasProperty("bintrayUser") && project.hasProperty("bintrayKey")) {
		apply plugin: "com.jfrog.bintray"
		bintray {
			user = project.bintrayUser
			key = project.bintrayKey
			publications = ["mavenJava"]
			pkg {
				repo = "spar-wings"
				name = project.name
				desc = project.description
				websiteUrl = "https://github.com/dai0304/spar-wings"
				issueTrackerUrl = "https://github.com/dai0304/spar-wings/issues"
				vcsUrl = "https://github.com/dai0304/spar-wings.git"
				licenses = ["Apache-2.0"]
				labels = ["AWS", "Spring framework"]
			}
		}
	}
}



// ======== wrapper ========
task wrapper(type: Wrapper) {
	gradleVersion = "2.12"
}
